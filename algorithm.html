<!DOCTYPE html>
<html lang="zh">
<head>
    <title>Enhanced Algorithm Roadmap</title>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <script src="https://unpkg.com/cytoscape/dist/cytoscape.min.js"></script>
    <script src="https://unpkg.com/dagre@0.8.5/dist/dagre.min.js"></script>
    <script src="https://unpkg.com/cytoscape-dagre@2.5.0/cytoscape-dagre.js"></script>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Helvetica Neue', Arial, sans-serif;
            margin: 0; padding: 0; background-color: #1a1a1a; color: #f0f0f0;
        }
        #cy { width: 100vw; height: 100vh; position: absolute; top: 0; left: 0; z-index: 1; }
        #modal-overlay {
            display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background-color: rgba(0, 0, 0, 0.6); z-index: 99;
        }
        #modal {
            position: fixed; z-index: 100; left: 50%; top: 50%; transform: translate(-50%, -50%);
            width: 90%; max-width: 600px; background-color: #2c2c2c; border: 1px solid #444;
            border-radius: 12px; box-shadow: 0 8px 30px rgba(0, 0, 0, 0.5); padding: 25px 30px;
        }
        #modal-content h2 {
            margin-top: 0; font-size: 24px; border-bottom: 1px solid #444;
            padding-bottom: 15px; margin-bottom: 15px;
        }
        #modal-content p {
            line-height: 1.6; margin-bottom: 20px; color: #ccc;
        }
        #modal-content h3 {
            font-size: 18px; margin-top: 25px; margin-bottom: 10px; color: #eee;
            border-bottom: 1px solid #444; padding-bottom: 8px;
        }
        #modal-content ul { list-style: none; padding: 0; max-height: 280px; overflow-y: auto; }
        #modal-content li { padding: 12px 0; border-bottom: 1px solid #444; }
        #modal-content li:last-child { border-bottom: none; }
        #modal-content li a { text-decoration: none; color: #58a6ff; font-weight: bold; transition: color 0.2s; }
        #modal-content li a:hover { color: #80bfff; }
    </style>
</head>
<body>
    <div id="cy"></div>
    <div id="modal-overlay">
        <div id="modal">
            <div id="modal-content"></div>
        </div>
    </div>

<script>
document.addEventListener('DOMContentLoaded', function() {

    const roadmapConfig = {
        nodes: [
            // 基础
            { id: 'list', label: 'List / Array', type: 'basic', details: {
                description: '数组是一种基本的数据结构，用于存储相同类型的元素集合。通过索引可以快速访问任何位置的元素。',
                exercises: [
                    { title: 'LeetCode 1: Two Sum', url: 'http://example.com' },
                    { title: 'LeetCode 217: Contains Duplicate', url: 'http://example.com' },
                    { title: 'LeetCode 26: Remove Duplicates from Sorted Array', url: 'http://example.com' },
                    { title: 'LeetCode 121: Best Time to Buy and Sell Stock', url: 'http://example.com' },
                    { title: 'LeetCode 48: Rotate Image', url: 'http://example.com' },
                ]
            }},
            { id: 'string', label: 'String', type: 'basic', details: {
                description: '字符串是由字符组成的序列。常见的操作包括查找、替换、分割等。',
                exercises: [
                    { title: 'LeetCode 344: Reverse String', url: 'http://example.com' },
                    { title: 'LeetCode 3: Longest Substring Without Repeating Characters', url: 'http://example.com' },
                    { title: 'LeetCode 125: Valid Palindrome', url: 'http://example.com' },
                    { title: 'LeetCode 242: Valid Anagram', url: 'http://example.com' },
                    { title: 'LeetCode 28: Implement strStr()', url: 'http://example.com' },
                ]
            }},
            { id: 'two_pointers', label: 'Two Pointers', type: 'basic', details: {
                description: '双指针是一种常用的技巧，用于在数组或链表中同时使用两个指针来解决问题，常用于优化时间和空间复杂度。',
                exercises: [
                    { title: 'LeetCode 167: Two Sum II', url: 'http://example.com' },
                    { title: 'LeetCode 88: Merge Sorted Array', url: 'http://example.com' },
                    { title: 'LeetCode 142: Linked List Cycle II', url: 'http://example.com' },
                    { title: 'LeetCode 283: Move Zeroes', url: 'http://example.com' },
                    { title: 'LeetCode 11: Container With Most Water', url: 'http://example.com' },
                ]
            }},
            { id: 'stack', label: 'Stack', type: 'basic', details: {
                description: '栈是一种后进先出（LIFO）的数据结构。常用于实现函数调用、表达式求值等。',
                exercises: [
                    { title: 'LeetCode 20: Valid Parentheses', url: 'http://example.com' },
                    { title: 'LeetCode 155: Min Stack', url: 'http://example.com' },
                    { title: 'LeetCode 71: Simplify Path', url: 'http://example.com' },
                    { title: 'LeetCode 84: Largest Rectangle in Histogram', url: 'http://example.com' },
                    { title: 'LeetCode 150: Evaluate Reverse Polish Notation', url: 'http://example.com' },
                ]
            }},
            { id: 'sorting', label: 'Sorting', type: 'basic', details: {
                description: '排序是将一组元素按照特定顺序排列的过程。常见的排序算法有冒泡排序、选择排序、插入排序、归并排序、快速排序等。',
                exercises: [
                    { title: 'LeetCode 75: Sort Colors', url: 'http://example.com' },
                    { title: 'LeetCode 56: Merge Intervals', url: 'http://example.com' },
                    { title: 'LeetCode 148: Sort List', url: 'http://example.com' },
                    { title: 'LeetCode 912: Sort an Array', url: 'http://example.com' },
                    { title: 'LeetCode 179: Largest Number', url: 'http://example.com' },
                ]
            }},
            { id: 'linked_list', label: 'Linked List', type: 'basic', details: {
                description: '链表是一种线性数据结构，其中元素不按连续的内存位置存储。每个元素（节点）包含数据和指向下一个节点的指针。',
                exercises: [
                    { title: 'LeetCode 206: Reverse Linked List', url: 'http://example.com' },
                    { title: 'LeetCode 21: Merge Two Sorted Lists', url: 'http://example.com' },
                    { title: 'LeetCode 141: Linked List Cycle', url: 'http://example.com' },
                    { title: 'LeetCode 19: Remove Nth Node From End of List', url: 'http://example.com' },
                    { title: 'LeetCode 234: Palindrome Linked List', url: 'http://example.com' },
                ]
            }},
            { id: 'queue', label: 'Queue', type: 'basic', details: {
                description: '队列是一种先进先出（FIFO）的数据结构。常用于任务调度、广度优先搜索等。',
                exercises: [
                    { title: 'LeetCode 225: Implement Stack using Queues', url: 'http://example.com' },
                    { title: 'LeetCode 232: Implement Queue using Stacks', url: 'http://example.com' },
                    { title: 'LeetCode 622: Design Circular Queue', url: 'http://example.com' },
                    { title: 'LeetCode 102: Binary Tree Level Order Traversal', url: 'http://example.com' },
                    { title: 'LeetCode 279: Perfect Squares', url: 'http://example.com' },
                ]
            }},
            { id: 'search', label: 'Search', type: 'basic' },
            
            // 中级
            { id: 'binary_search', label: 'Binary Search', type: 'intermediate', details: {
                description: '二分搜索是一种高效的搜索算法，适用于已排序的数据集合。通过不断缩小搜索范围，快速找到目标元素。',
                exercises: [
                    { title: 'LeetCode 704: Binary Search', url: 'http://example.com' },
                    { title: 'LeetCode 34: Find First and Last Position', url: 'http://example.com' },
                    { title: 'LeetCode 33: Search in Rotated Sorted Array', url: 'http://example.com' },
                    { title: 'LeetCode 162: Find Peak Element', url: 'http://example.com' },
                    { title: 'LeetCode 875: Koko Eating Bananas', url: 'http://example.com' },
                ]
            }},
            { id: 'tree', label: 'Tree', type: 'intermediate', details: {
                description: '树是一种分层的数据结构，由节点和连接节点的边组成。常见的类型包括二叉树、平衡树、搜索树等。',
                exercises: [
                    { title: 'LeetCode 104: Maximum Depth of Binary Tree', url: 'http://example.com' },
                    { title: 'LeetCode 98: Validate Binary Search Tree', url: 'http://example.com' },
                    { title: 'LeetCode 102: Binary Tree Level Order Traversal', url: 'http://example.com' },
                    { title: 'LeetCode 235: Lowest Common Ancestor of a BST', url: 'http://example.com' },
                    { title: 'LeetCode 226: Invert Binary Tree', url: 'http://example.com' },
                ]
            }},
            { id: 'backtracking', label: 'Backtracking', type: 'intermediate', details: {
                description: '回溯是一种通过尝试所有可能的解决方案并撤销不合适的选择来找到问题的解的算法范式。',
                exercises: [
                    { title: 'LeetCode 78: Subsets', url: 'http://example.com' },
                    { title: 'LeetCode 46: Permutations', url: 'http://example.com' },
                    { title: 'LeetCode 39: Combination Sum', url: 'http://example.com' },
                    { title: 'LeetCode 79: Word Search', url: 'http://example.com' },
                    { title: 'LeetCode 51: N-Queens', url: 'http://example.com' },
                ]
            }},
            { id: 'heap', label: 'Heap / Priority Queue', type: 'intermediate', details: {
                description: '堆是一种特殊的基于树的数据结构。优先队列是一种抽象数据类型，通常使用堆来实现，它提供了访问具有最高（或最低）优先级的元素的能力。',
                exercises: [
                    { title: 'LeetCode 215: Kth Largest Element in an Array', url: 'http://example.com' },
                    { title: 'LeetCode 295: Find Median from Data Stream', url: 'http://example.com' },
                    { title: 'LeetCode 23: Merge k Sorted Lists', url: 'http://example.com' },
                    { title: 'LeetCode 347: Top K Frequent Elements', url: 'http://example.com' },
                    { title: 'LeetCode 692: Top K Frequent Words', url: 'http://example.com' },
                ]
            }},
            { id: 'trie', label: 'Trie (Prefix Tree)', type: 'intermediate', details: {
                description: 'Trie，又称前缀树或字典树，是一种树状数据结构，用于高效地存储和检索字符串数据集中的键。常用于自动补全和拼写检查等场景。',
                exercises: [
                    { title: 'LeetCode 208: Implement Trie', url: 'http://example.com' },
                    { title: 'LeetCode 211: Design Add and Search Words', url: 'http://example.com' },
                    { title: 'LeetCode 212: Word Search II', url: 'http://example.com' },
                    { title: 'LeetCode 648: Replace Words', url: 'http://example.com' },
                    { title: 'LeetCode 336: Palindrome Pairs', url: 'http://example.com' },
                ]
            }},
            { id: 'dp_1d', label: '1D Dynamic Programming', type: 'intermediate', details: {
                description: '一维动态规划是一种通过将问题分解为更小的重叠子问题并存储子问题的解来优化解决复杂问题的技术。',
                exercises: [
                    { title: 'LeetCode 70: Climbing Stairs', url: 'http://example.com' },
                    { title: 'LeetCode 198: House Robber', url: 'http://example.com' },
                    { title: 'LeetCode 322: Coin Change', url: 'http://example.com' },
                    { title: 'LeetCode 53: Maximum Subarray', url: 'http://example.com' },
                    { title: 'LeetCode 300: Longest Increasing Subsequence', url: 'http://example.com' },
                ]
            }},

            // 高级
            { id: 'graph', label: 'Graph', type: 'advanced', details: {
                description: '图是一种由节点（顶点）和连接节点的边组成的数据结构，用于表示对象之间的关系。',
                exercises: [
                    { title: 'LeetCode 200: Number of Islands', url: 'http://example.com' },
                    { title: 'LeetCode 133: Clone Graph', url: 'http://example.com' },
                    { title: 'LeetCode 417: Pacific Atlantic Water Flow', url: 'http://example.com' },
                    { title: 'LeetCode 207: Course Schedule (Topological Sort)', url: 'http://example.com' },
                    { title: 'LeetCode 787: Cheapest Flights Within K Stops (Dijkstra)', url: 'http://example.com' },
                ]
            }},
            { id: 'dp_2d', label: '2D Dynamic Programming', type: 'advanced', details: {
                description: '二维动态规划是动态规划的一种扩展，用于解决涉及二维结构（如网格）的问题。',
                exercises: [
                    { title: 'LeetCode 62: Unique Paths', url: 'http://example.com' },
                    { title: 'LeetCode 64: Minimum Path Sum', url: 'http://example.com' },
                    { title: 'LeetCode 72: Edit Distance', url: 'http://example.com' },
                    { title: 'LeetCode 1143: Longest Common Subsequence', url: 'http://example.com' },
                    { title: 'LeetCode 221: Maximal Square', url: 'http://example.com' },
                ]
            }},

            // 其余未添加详细内容的节点
            { id: 'quick_search', label: 'Quick Search', type: 'intermediate' },
            { id: 'parentheses', label: 'Parentheses & Calculator', type: 'intermediate' },
            { id: 'permutations', label: 'Permutations & Combinations', type: 'intermediate' },
            { id: 'shunting_yard', label: 'Shunting-yard Algorithm', type: 'advanced' },
            { id: 'dfs_bfs', label: 'DFS / BFS', type: 'advanced' },
        ],
        edges: [
            { from: 'list', to: 'string' }, { from: 'list', to: 'two_pointers' }, { from: 'list', to: 'stack' },
            { from: 'list', to: 'sorting' }, { from: 'list', to: 'linked_list' }, { from: 'list', to: 'queue' },
            { from: 'list', to: 'backtracking' },
            { from: 'sorting', to: 'search' },
            { from: 'search', to: 'quick_search' }, { from: 'search', to: 'binary_search' },
            { from: 'stack', to: 'parentheses' },
            { from: 'parentheses', to: 'shunting_yard' },
            { from: 'linked_list', to: 'tree' }, { from: 'binary_search', to: 'tree' },
            { from: 'tree', to: 'graph' }, { from: 'tree', to: 'heap' }, { from: 'tree', to: 'trie' },
            { from: 'backtracking', to: 'permutations' }, { from: 'backtracking', to: 'dp_1d' },
            { from: 'graph', to: 'dfs_bfs' }, { from: 'backtracking', to: 'dfs_bfs' },
            { from: 'graph', to: 'dp_2d' }, { from: 'dp_1d', to: 'dp_2d' },
        ],
        colorPalette: {
            basic:        { main: '#0d6efd', border: '#58a6ff' },
            intermediate: { main: '#0B5ED7', border: '#3C82F7' },
            advanced:     { main: '#DC3545', border: '#E57373' },
            reserved1:    { main: '#FFC107', border: '#FFD54F' },
            reserved2:    { main: '#198754', border: '#4CAF50' }
        }
    };

    function initializeRoadmap(config) {
        const elements = [
            ...config.nodes.map(node => ({ data: node })),
            ...config.edges.map(edge => ({ data: { source: edge.from, target: edge.to } }))
        ];

        const styles = [
            { selector: 'node', style: {
                'label': 'data(label)', 'color': '#ffffff', 'text-valign': 'center',
                'text-halign': 'center', 'font-size': '16px', 'font-weight': 'bold',
                'shape': 'round-rectangle', 'width': 'label', 'padding': '16px 20px',
                'height': '48px', 'border-width': 2.5,
            }},
            { selector: 'edge', style: {
                'width': 2.5, 'line-color': '#6c757d', 'curve-style': 'bezier',
                'target-arrow-shape': 'triangle', 'target-arrow-color': '#6c757d',
                'arrow-scale': 1.2
            }}
        ];

        for (const [type, colors] of Object.entries(config.colorPalette)) {
            styles.push({
                selector: `node[type='${type}']`,
                style: {
                    'background-color': colors.main,
                    'border-color': colors.border
                }
            });
        }

        const cy = cytoscape({
            container: document.getElementById('cy'),
            elements: elements,
            style: styles,
            layout: {
                name: 'dagre', rankDir: 'TB', spacingFactor: 1.2,
                nodeSep: 60, rankSep: 70,
            }
        });
        
        const modalOverlay = document.getElementById('modal-overlay');
        const modalContent = document.getElementById('modal-content');

        cy.on('tap', 'node', function(evt){
            const node = evt.target;
            const details = node.data('details');
            if (!details) return;

            const nodeType = node.data('type');
            const titleColor = config.colorPalette[nodeType]?.border || '#ffffff';

            let contentHtml = `<h2 style="color:${titleColor}">${node.data('label')}</h2>`;
            if (details.description) {
                contentHtml += `<p>${details.description}</p>`;
            }
            if (details.exercises && details.exercises.length > 0) {
                contentHtml += '<h3>练习习题</h3><ul>';
                details.exercises.forEach(exercise => {
                    contentHtml += `<li><a href="${exercise.url}" target="_blank">${exercise.title}</a></li>`;
                });
                contentHtml += '</ul>';
            }

            modalContent.innerHTML = contentHtml;
            modalOverlay.style.display = 'block';
        });

        modalOverlay.addEventListener('click', function(event) {
            if (event.target === modalOverlay) {
                modalOverlay.style.display = 'none';
            }
        });
    }

    initializeRoadmap(roadmapConfig);
});
</script>

</body>
</html>